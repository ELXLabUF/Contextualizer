"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupFirebase = exports.generateFirebaseJson = exports.ngAddSetupProject = exports.setupProject = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const utils_1 = require("../utils");
const prompts_1 = require("./prompts");
const firebaseTools_1 = require("../firebaseTools");
const fs_1 = require("fs");
const path_1 = require("path");
const common_1 = require("../common");
const setupProject = (tree, context, features, config) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { path: workspacePath, workspace } = utils_1.getWorkspace(tree);
    const { project, projectName } = utils_1.getProject(config, tree);
    const sourcePath = (_a = project.sourceRoot) !== null && _a !== void 0 ? _a : project.root;
    utils_1.addIgnoreFiles(tree);
    const featuresToImport = features.filter(it => it !== 0);
    if (featuresToImport.length > 0) {
        utils_1.addToNgModule(tree, { features: featuresToImport, sourcePath });
        utils_1.addFixesToServer(tree, { features: featuresToImport, sourcePath });
    }
    if (config.sdkConfig) {
        const source = `
  firebase: {
${Object.entries(config.sdkConfig).reduce((c, [k, v]) => c.concat(`    ${k}: '${v}'`), []).join(',\n')},
  }`;
        const environmentPath = `${sourcePath}/environments/environment.ts`;
        utils_1.addEnvironmentEntry(tree, `/${environmentPath}`, source);
        Object.values(project.architect || {}).forEach(builder => {
            Object.values(builder.configurations || {}).forEach(configuration => {
                (configuration.fileReplacements || []).forEach((replacement) => {
                    if (replacement.replace === environmentPath) {
                        utils_1.addEnvironmentEntry(tree, `/${replacement.with}`, source);
                    }
                });
            });
        });
    }
    const options = {
        project: projectName,
        firebaseProject: config.firebaseProject,
        firebaseApp: config.firebaseApp,
        firebaseHostingSite: config.firebaseHostingSite,
        sdkConfig: config.sdkConfig,
        prerender: undefined,
        browserTarget: config.browserTarget,
        serverTarget: config.serverTarget,
        prerenderTarget: config.prerenderTarget,
        ssrRegion: config.ssrRegion,
    };
    if (features.includes(0)) {
        return exports.setupFirebase({
            workspace,
            workspacePath,
            options,
            tree,
            context,
            project
        });
    }
    else {
        return Promise.resolve();
    }
});
exports.setupProject = setupProject;
const ngAddSetupProject = (options) => (host, context) => __awaiter(void 0, void 0, void 0, function* () {
    let projectRoot = host._backend._root;
    if (process.platform.startsWith('win32')) {
        projectRoot = core_1.asWindowsPath(core_1.normalize(projectRoot));
    }
    const features = yield prompts_1.featuresPrompt();
    if (features.length > 0) {
        const firebaseTools = yield firebaseTools_1.getFirebaseTools();
        if (!host.exists('/firebase.json')) {
            fs_1.writeFileSync(path_1.join(projectRoot, 'firebase.json'), '{}');
        }
        const user = yield prompts_1.userPrompt({ projectRoot });
        yield firebaseTools.login.use(user.email, { projectRoot });
        const { project: ngProject, projectName: ngProjectName } = utils_1.getProject(options, host);
        const [defaultProjectName] = utils_1.getFirebaseProjectNameFromHost(host, ngProjectName);
        const firebaseProject = yield prompts_1.projectPrompt(defaultProjectName, { projectRoot, account: user.email });
        let hosting = {};
        let firebaseHostingSite;
        if (features.includes(0)) {
            const results = yield prompts_1.projectTypePrompt(ngProject, ngProjectName);
            hosting = Object.assign(Object.assign({}, hosting), results);
            firebaseHostingSite = yield prompts_1.sitePrompt(firebaseProject, { projectRoot });
        }
        let firebaseApp;
        let sdkConfig;
        if (features.find(it => it !== 0)) {
            const defaultAppId = firebaseHostingSite === null || firebaseHostingSite === void 0 ? void 0 : firebaseHostingSite.appId;
            firebaseApp = yield prompts_1.appPrompt(firebaseProject, defaultAppId, { projectRoot });
            const result = yield firebaseTools.apps.sdkconfig('web', firebaseApp.appId, { nonInteractive: true, projectRoot });
            sdkConfig = result.sdkConfig;
        }
        yield exports.setupProject(host, context, features, Object.assign(Object.assign(Object.assign({}, options), hosting), { firebaseProject, firebaseApp, firebaseHostingSite, sdkConfig }));
    }
});
exports.ngAddSetupProject = ngAddSetupProject;
function generateFirebaseJson(tree, path, project, region) {
    const firebaseJson = tree.exists(path)
        ? common_1.safeReadJSON(path, tree)
        : {};
    const newConfig = {
        target: project,
        source: '.',
        frameworksBackend: {
            region
        }
    };
    if (firebaseJson.hosting === undefined) {
        firebaseJson.hosting = [newConfig];
    }
    else if (Array.isArray(firebaseJson.hosting)) {
        const existingConfigIndex = firebaseJson.hosting.findIndex(config => config.target === newConfig.target);
        if (existingConfigIndex > -1) {
            firebaseJson.hosting.splice(existingConfigIndex, 1, newConfig);
        }
        else {
            firebaseJson.hosting.push(newConfig);
        }
    }
    else {
        firebaseJson.hosting = [firebaseJson.hosting, newConfig];
    }
    common_1.overwriteIfExists(tree, path, common_1.stringifyFormatted(firebaseJson));
}
exports.generateFirebaseJson = generateFirebaseJson;
const setupFirebase = (config) => {
    const { tree, workspacePath, workspace, options } = config;
    const project = workspace.projects[options.project];
    if (!project.architect) {
        throw new schematics_1.SchematicsException(`Angular project "${options.project}" has a malformed angular.json`);
    }
    project.architect.deploy = {
        builder: '@angular/fire:deploy',
        options: Object.assign(Object.assign({ version: 2, browserTarget: options.browserTarget }, (options.serverTarget ? { serverTarget: options.serverTarget } : {})), (options.prerenderTarget ? { prerenderTarget: options.prerenderTarget } : {}))
    };
    tree.overwrite(workspacePath, JSON.stringify(workspace, null, 2));
    generateFirebaseJson(tree, 'firebase.json', options.project, options.ssrRegion);
    common_1.generateFirebaseRc(tree, '.firebaserc', options.firebaseProject.projectId, options.firebaseHostingSite, options.project);
    return tree;
};
exports.setupFirebase = setupFirebase;
